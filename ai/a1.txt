/** <examples>

?- astar([q],Path,Cost,
[[q,a],[q,b,c],[a,d,e],[a,c,e,f],[b,c],[c,e,f],[e],[f,e]]).
?- astar([q],Path,Cost,[[q,a],[q,b,c],[a],[b],[c]]).

*/

% KB =
% [[q,a],[q,b,c],[a,d,e],[a,c,e,f],[b,c],[c,e,f],[e],[f,e]]

% astar(+Node,?Path,?Cost,+KB)
% Returns path from Node to goal node []

q:- a.
q:- b,c.
a:- d,e.
a:- c,e,f.
b:- c.
c:- e,f.
d :- fail.
e.
f:- e.

astar(Node, Path, Cost, KB) :- search(Node,Path,Cost,KB).

arc([H|T],Node,Cost,KB) :- member([H|B],KB),
    append(B,T,Node),
    length(B,L),
    Cost is 1+ L/(L+1).

heuristic(Node,H) :- length(Node,H).

goal([]).

% BFS version
% e.g add2frontier([a,b], [c], R)
% gives R = [c,a,b]
add2frontier(Children,[],Children).
%add2frontier(Children,[H|T],[H|More]) :- 
%    less-than([H|T],Children),
%	add2frontier(Children,T,More).
add2frontier(Children,[H|T],NewFrontier) :-
    less-than(H,Children),
    add2frontier(Children,T,NewFrontier).

% Modify skeletal search algorithm
% head of list New obtained in add2frontier has f-value no
% larger than any in New's tail
% f(node) = cost(node) + h(node).


% _ is KB
% modify findall to get list of path-cost pairs
% add2frontrier should return list of path-cost pairs
% with lowest heuristic value at head
search([Node|_],_,_,_) :- goal(Node).
search([Node|More],Path, Cost, KB) :- 
    findall([X,ArcCost],arc(Node,X,ArcCost,KB),Children),
	add2frontier(Children,More,NewFrontier),
    NewCost is Cost+ArcCost,
    append(Path, X, NewPath),
	search(NewFrontier,NewPath,NewCost,KB).


% Let frontier be list of path-cost pairs (not just nodes)
% Make sure to update path cost, and bring in heuristic function to 
% form frontier New
less-than([[Node1|_],Cost1],[[Node2|_],Cost2]) :-
	heuristic(Node1,Hvalue1),
    heuristic(Node2,Hvalue2),
    F1 is Cost1+Hvalue1, 
    F2 is Cost2+Hvalue2,
	F1 =< F2.
